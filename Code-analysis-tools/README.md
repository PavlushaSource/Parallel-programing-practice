## Task done

Работа выполнена в [форке](https://github.com/PavlushaSource/parallel-programing-task-2) репозитория, в котором с
помощью
ThreadSanitizer были устранены гонки данных и другие ошибки параллельного программирования.

Репозиторий имплементирует задачу об обедающих философах без какой-либо стратегии.

- Deadlock не происходит за счёт указания
  времени смерти каждого из философов и если один из них всё-таки умирает, то остальные завершают свои действия и
  программа останавливается.
- Livelock не наступает засчёт того, что сначала обедать начинают философы с нечётными номерами.

---

## Repo before

В Makefile проекта в папке `/philo`, где была реализована задача о философах, не был
выставлен флаг компиляции `-fsanitize=thread` и по просмотренным коммитам стало ясно,
что во время написания кода человек не пользовался какими-либо утилитами для анализа своего параллельного кода,
вследствие этого возникло множество гонок данных, destroy залоченного мьютекса и т.д.

**Запуск c флагом `-fsanitize=thread -g`**:

- `WARNING: ThreadSanitizer: unlock of an unlocked mutex`
- `WARNING: ThreadSanitizer: destroy of a locked mutex`
- `WARNING: ThreadSanitizer: data race`

threadSanitizer: reported 13 warnings


----

Для лучшей экспертизы также был использован инструмент `helgrind`, который обнаружил 2 ошибки, связанных с гонкой
данных.

**Команда для запуска**

```
valgrind --tool=helgrind ./philo 5 800 200 200 7
```

**Пример вывода helgrind**

- `Possible data race during read of size 1 at 0x1FFEFF86D8 by thread #1`

  `This conflicts with a previous write of size 4 by thread #7`
- `Thread #1: pthread_mutex_destroy of a locked mutex`

ERROR SUMMARY: 20 errors from 7 contexts (suppressed: 36 from 9)

---

## What's wrong

### Логика работы кратко

При старте приложения происходит инициализация необходимых структур данных, в том числе мьютексов. После чего
запускается лаунчер который, инициирует запуск потоков для философов, крутящих бесконечные циклы, и запуск потока для
сущности `obsorver` проверяющей условия окончания трапезы. В лаунчере ожидается окончании работы `obsorver`, после чего
вызывается функция `destroy_all`, разрушающая мьютексы, и приложение заканчивает работу.

### Из-за чего гонка

Когда все философы наелись или один из них умер, `observer` убеждается в этом и вызывает функцию `destroy_all`, однако
философ, может не успевать освободить один из мьютексов, который будет разрушен функцией `destroy_all`. Из этого следует
ошибка, которую обнаружили обе утилиты `WARNING: ThreadSanitizer: destroy of a locked mutex`.

Из этой проблемы следует и `WARNING: ThreadSanitizer: unlock of an unlocked mutex`, когда после разрушения мьютекса
поток пытается пытается его освободить.

Проблема `WARNING: ThreadSanitizer: data race` возникает из-за описанных выше проблем, так как нам неизвестно, что
произойдёт раньше - разрушится мьютекс или поток философа успеет его освободить.

**TL;DR**

Вызов `pthread_mutex_destroy()` c переданным заблокированным мьютексом приводит к непредсказуемому поведению.

### Как решена проблема

Идея решения: нужно научиться гарантировать то, что мьютексы свободны непосредственно перед попыткой их
разрушения.

Решением данной проблемы будет перенесение проверки условий окончания трапезы в потоки философов, для этого всего лишь
нужно ввести общий флаг, который будет выставлен в значение `true`, когда все филосовы вдволь пообедают или кто-то из
них умрёт. Таким образом, сущность `obsorver` удаляется за ненадобностью. А мьютексы разрушаются после завершения работы
потоков философов. Исправления можно найти в ветке `fix/data-race` в вышеупомянутом форке. Там же можно запустить
**Thread Sanitizer** и **Helgrind**

---

## Repo after

После исправления логики работы `observer` и замены `lock_mutex` на `try_lock_mutex` в некоторых местах, удалось
исправить все ошибки, которые выдавал Thread Sanitizer.

Оставив Makefile с флагом `-fsanitize=thread -g`, наша программа больше не печатает ни одного лога, связанного с
ошибками **Thread Sanitizer** и философы успешно кушают и думают в соответствии с заданными аргументами.

При использовании **Helgrind** ошибки, связанные с гонкой данных также пропали, однако он продолжит выводить ошибки,
связанные с блокировкой мьютексов вилок разными философами, однако это часть логики работы программы, а не ошибка 
__заставляем их ждать, если нужные столовые приборы заняты__

----

## Эпилог для будущих поколений

- Не запускайте helgrind вместе с `-fsanitize=thread -g`, если Thread Sanitizer **выдаёт ошибки**. Грозит
  крашем всей ОС и автоматической перезагрузкой.
- Если у вас есть ошибка: `FATAL: ThreadSanitizer: unexpected memory mapping 0x56dab80d5000-0x56dab80d6000`, то
  я вам искренне сочувствую. Попробуйте
  почитать [это](https://stackoverflow.com/questions/77850769/fatal-threadsanitizer-unexpected-memory-mapping-when-running-on-linux-kernels)
  . Запускался на ядре 6.5.0, пробовал gcc 13.1.0 и clang 14.0.0 не помогло, отключение ASLR тоже не дало результатов.